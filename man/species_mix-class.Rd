% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/species_mix-class.R
\name{species_mix}
\alias{species_mix}
\alias{species_mix.fit}
\alias{species_mix.fit}
\alias{species_mix.multifit}
\alias{control}
\alias{species_mix.control}
\alias{simulate_species_mix_data}
\alias{species_mix_estimate_groups}
\alias{species_mix.predict}
\title{species_mix objects}
\usage{
species_mix(archetype_formula = NULL,
  species_formula = stats::as.formula(~1), data, n_mixtures = 3,
  distribution = "bernoulli", offset = NULL, weights = NULL,
  control = species_mix.control(), inits = NULL, standardise = FALSE,
  titbits = TRUE)

species_mix.fit(y, X, W = NULL, G, weights, offset, distribution_numeric,
  control, y_is_na = NULL, inits = NULL, archetype_formula = NULL,
  species_formula = NULL)

species_mix.multifit(archetype_formula = NULL, species_formula = ~1, data,
  distribution = "bernoulli", nstart = 10, n_mixtures = 3,
  offset = NULL, weights = NULL, control = species_mix.control(),
  inits = NULL, standardise = FALSE)

species_mix.control(maxit = 1000, quiet = FALSE, trace = 1, cores = 1,
  residuals = FALSE, init_method = "kmeans", init_sd = 1,
  em_prefit = TRUE, em_steps = 3, em_refit = 3, em_maxit = 3,
  em_abstol = sqrt(.Machine$double.eps), em_reltol = reltol_fun,
  em_maxtau = 0.8, em_calculate_hessian = FALSE, em_full_model = FALSE,
  r1 = 1, maxit_cpp = 1000, trace_cpp = 0, nreport_cpp = 1,
  abstol_cpp = sqrt(.Machine$double.eps),
  reltol_cpp = sqrt(.Machine$double.eps), conv_cpp = 1,
  printparams_cpp = 0, optimise_cpp = 1, loglOnly_cpp = 0,
  derivOnly_cpp = 0, getscores_cpp = 0, calculate_hessian_cpp = TRUE, ...)

simulate_species_mix_data(archetype_formula, species_formula, dat, theta,
  distribution = "bernoulli")

species_mix_estimate_groups(archetype_formula = NULL, species_formula = ~1,
  data, n_mixtures = 1:10, distribution = "bernoulli", offset = NULL,
  weights = NULL, control = species_mix.control(), inits = NULL,
  standardise = FALSE)

species_mix.predict(object, new_obs, ...)
}
\arguments{
\item{species_formula}{an object of class "formula" (or an object that can be
coerced to that class). The right hand side of this formula specifies the
dependence of the species"'" data on covariates (typically different covariates
to \code{archetype_formula} to avoid confusing confounding). Current the formula
is set at ~ 1 by default for species-specific intercepts for the archetype models.
If you include a species specific formula which has more than an intercept you
will be fitting a partial species archetype model which has species
specific covariates and archetype specific covariates.}

\item{n_mixtures}{The number of mixing components (groups) to fit.}

\item{distribution}{The family of statistical distribution to use within
the ecomix models. a  choice between "bernoulli", "poisson",
"ippm" (inhomogeneous Poisson point process model), "negative_binomial", "tweedie"
and "gaussian" distributions are possible and applicable to specific types
of data.}

\item{offset}{a numeric vector of length nrow(data) (n sites) that is included into
the model as an offset. It is included into the conditional part of the model
where conditioning is performed on the SAM.}

\item{weights}{a numeric vector of length ncol(Y) (n species) that is used as weights
in the log-likelihood calculations. If NULL (default) then all weights are
assumed to be identically 1. Because we are estimating the log-likelihood
over species (rather than sites), the weights should be a vector n species
long. The exception is under the use of the 'ippm' distribution where
weights must be a nrow(data)*n_species matrix, which provides a
species-specific background weights used to estimate the species-specific
marginal likelihoods.}

\item{control}{a list of control parameters for optimisation and calculation.
See details. From \code{species_mix.control} for details on optimistaion
parameters.}

\item{inits}{NULL a numeric vector that provides approximate starting values
for species_mix coefficents. These are distribution specific, but at a
minimum you will need pis (additive_logitic transformed), alphas
(intercepts) and betas (mixing coefs).}

\item{y}{is a matrix genertated from \link[stats]{model.response} containing the species information. The matrix has the dimensions n_sites * n_species.}

\item{X}{is a design matrix for the archetype_formula dimension n_sites * n_covariates.}

\item{W}{is a design matrix for species_formula and will be implemented if species_formula has covariates.}

\item{G}{is the number of species archetypes that are being estimated.}

\item{distribution_numeric}{the error distribution to used in species_mix estimation. Currently, 'bernoulli', 'poisson', 'ippm' (Poisson point process), 'negative_binomial' and 'tweedie' are avaliable - internal conversion of distribution to a integer.}

\item{y_is_na}{This is a logical matrix used specifically with 'ippm' modelling - don't worry about this, it'll be worked out for you. Yay!}

\item{maxit}{Maximum number of evaluations of the objective function allowed. Defaults to 500.}

\item{trace}{int 1=model will report parameter estimates and loglikelihood at each iteration. 0=quite.}

\item{cores}{The number of cores to use in fitting of species mix models. These will be largely used to model the species-specific parameteres.}

\item{residuals}{logical if TRUE model will estimate residuals.}

\item{em_prefit}{Logical if TRUE the model will run a slower EM algorithim fit to find starting values.}

\item{em_steps}{int Default is 3, the number of EM iterations to get to starting values.}

\item{em_refit}{int Default is 1, number of times to refit using EM.}

\item{dat}{a matrix of variables to simulate data from.}

\item{theta}{coefficents for each species archetype. Matrix of G x number of parameters. Each row is a different species archetype.}

\item{object}{is a matrix model returned from the species_mix model.}

\item{new_obs}{a matrix of new observations for prediction.}

\item{archetype_fromula}{an object of class "formula" (or an object that can be
coerced to that class). The response variable (left hand side of the
formula) needs to be either 'presence', 'occurrence', 'abundance',
'biomass' or 'quantity' data. The type of reponse data will help specify
the type of error distribution to be used. The dependent variables
(the right hind side) of this formula specifies the dependence of the
species archetype probabilities on covariates. For all model the basic
formula structure follows something like this:
cbind(spp1,spp2,spp3)~1+temperature+rainfall}

\item{model_data}{a matrix of dataframe which contains the 'species_data'
matrix, a const and the covariates in the strucute of spp1, spp2, spp3,
const, temperature, rainfall. dims of matirx should be
nsites*(nspecies+const+covariates).}

\item{weights}{is used in alternative way depending on the error distribution used. See \link[ecomix]{species_mix} for more details.}

\item{offset}{this is a vector of site specific offsets, this might be something like area sampled at sites.}

\item{control}{this is a list of control parameters that alter the specifics of model fitting. See \link[ecomix]{species_mix.control} for details.}

\item{quite}{Should any reporting be performed? Default is FALSE, for reporting.}

\item{reltol}{function that determines the relative tolernace for model convergence. Default is quite strict.}

\item{calculate_hessian}{logical if TRUE model will numerically estimate the variance covariance matrix.}

\item{archtype_formula}{formula to simulate species_mix data, needs to have the format: cbind(spp1,spp2,spp3,...,sppN)~1 + x1 + x2}

\item{species_formula}{formula to simulate species_mix species-specific responses, e.g: ~1}

\item{distribution}{Which statistical distribution to simulate data for. 'bernoulli', 'gaussian', 'ippm', 'negative_binomial','poisson' and 'tweedie'.}
}
\description{
Fits a finite mixture model to identify species archetype
models (SAMs).

This function runs the 'species_mix' function but it iterates through groups (1 to 10) by default.

Predicts SAM probabilities at a series of sites. Confidence intervals can be calculated if variance-covariance matrix is estimated during species_mix model fit.
}
\details{
species_mix is used to fit mixtures of glms to multivariate
species data. The function uses BFGS to optimise the mixture likelihood.
There is the option to use EM algorithm to get appropriate starting parameters.
`species_mix` acts as a wrapper for fitmix.cpp that allows for easier data
input. The data frames are merged into the appropriate format for the use
in fitmix.cpp. Minima is found using vmmin (BFGS). Currently 'bernoulli',
'poisson', 'ippm' (inhomogenous Poisson point process), 'negative_binomial'
 and 'tweedie' distributions can be fitted using the species_mix function.
}
\examples{
\dontrun{
library(ecomix)
set.seed(42)
sam_form <- stats::as.formula(paste0('cbind(',paste(paste0('spp',1:20),collapse = ','),")~1+x1+x2"))
sp_form <- ~ 1
theta <- matrix(c(1,-2.9,-3.6,1,-0.9,1,1,.9,7.9),3,3,byrow=TRUE)
dat <- data.frame(y=rep(1,100),x1=stats::runif(100,0,2.5),x2=stats::rnorm(100,0,2.5))
dat[,-1] <- scale(dat[,-1])
simulated_data <- simulate_species_mix_data(archetype_formula=sam_form, species_formula=sp_form,
                                            dat,theta,dist="bernoulli")
model_data <- make_mixture_data(species_data = simulated_data$species_data,
                                covariate_data = simulated_data$covariate_data[,-1])
fm1 <- species_mix(sam_form, sp_form, model_data, distribution = 'bernoulli',
 n_mixtures=3)
}
\dontrun{
fmods <- species_mix.multifit(sam_form, sp_form, model_data, distribution = 'bernoulli', nstarts = 10, n_mixtures=3)
}
\dontrun{
archetype_formula <- stats::as.formula(paste0('cbind(',paste(paste0('spp',1:20),collapse = ','),")~1+x1+x2"))
theta <- matrix(c(-0.9,-0.6,0.5,1,-0.9,1,0.9,-0.9,2.9,-1,0.2,-0.4),4,3,byrow=TRUE)
dat <- data.frame(y=rep(1,100),x1=stats::runif(100,0,2.5),x2=stats::rnorm(100,0,2.5))
simulated_data <- simulate_species_mix_data(archetype_formula,~1,dat,theta,dist="bernoulli")
}
\dontrun{
fm1 <- species_mix(form,data)
preds_fm1 <- predict(fm1,newdata)}
}
