---
title: "ippm_sam_myrtaceae"
author: "Skipton Woolley"
date: "August 22, 2017"
output: html_document
---

## Models and testing of Imhomogenous Point Process Species Archetype Models.

Here I'm going to try and fit and test the validity and robustness of ipp-sams using some trees. 
```{r load functions}
library(qrbp)
library(ecomix)
```

Let's have a look at the euc and physical data.
```{r load euc}
load('~/Dropbox/ecomix/data/AtlasMyrtaceae2012.RData')
load('~/Dropbox/ecomix/data/Quad1000.RData')
load('~/Dropbox/ecomix/data/Substrate1km.RData')
envdat <- cbind(quad,subs.quad)
```

Let's plot the environmental data.
```{r}
library(raster)
b <- rasterFromXYZ(envdat)
plot(b)
```

let's remove any coordinates which sit outside our study area.
```{r}
checkNA <- extract(b,big.myrt[,c("X","Y")],method='bilinear')
na_sites <-which(is.na(checkNA[,1]))
myrt<-big.myrt[-na_sites,]
```

now let's look at the myrtaceae distributions.

325 species.
127 species > 49 occurrences
177 species > 19 occurrences
217 species > 9 occurrences
257 species > 4 occurrences

```{r}
tot_occur <- table(myrt$ScientificName)
sum(tot_occur>49)
sum(tot_occur>19)
sum(tot_occur>9)
sum(tot_occur>4)
```

Let's start with > 50 as a gentle warm in.
```{r}
spps <- names(which(table(myrt$ScientificName)>49))
myrt50occ <- myrt[myrt$ScientificName%in%spps,]
#works but slow and takes lots of
# myrt50occ$ScientificName <- factor(myrt50occ$ScientificName)
# d <- transform(myrt50occ, site_id = as.numeric(interaction(X, Y, drop=TRUE)))
library(data.table)
dt <- data.table(myrt50occ, key="X,Y")
dt[, site_id:=.GRP, by=key(dt)]
df <- as.data.frame(dt)
df$ScientificName<- factor(df$ScientificName)
po_matrix <- bbgdm::table2pam(df,site.id='site_id',sp.id='ScientificName')

po_matrix[po_matrix==0]<-NA

d <- df[order(df$site_id),]
d_no_site_dups <- d[!duplicated(d$site_id),]

pres_coords <- d_no_site_dups[c("site_id","X","Y")]
colnames(pres_coords)[-1]<-c('x','y')
po_matrix_coords <- cbind(pres_coords[,-1],po_matrix)
```

```{r}
library(qrbp)
n_bk_pts <- 10000
covar <- stack(b)
# covar2 <- (covar)^2
# names(covar)<-c('min_temp','max_temp','annual_rainfall','soil_type')
# names(covar2) <- paste0(c('min_temp','max_temp','annual_rainfall','soil_type'),2)
# covars <- stack(covar,covar2)
po_bkgrd_data <- generate_background_points(n_bk_pts,
  known_sites = pres_coords[,-1],
  study_area = covar[[1]],
  model_covariates = covar,
  multispecies_presences = po_matrix_coords,
  method = 'multispecies',
  interpolation_method = 'bilinear')

dat <- po_bkgrd_data$model_matrix
wts <- po_bkgrd_data$species_weights
```
Now let's try a fit a ippsam with these data. Fingers crossed.
```{r}
# library(mgcv)
sp_names <- colnames(dat)[1:127]
colnames(dat)
form <- as.formula(paste0("cbind(",paste(sp_names[1:60],collapse = ','),")~ 1 + poly(x,y,degree=2) + poly(AR,degree=2) + poly(D.Main,degree=2) + poly(MNT, degree=2) + poly(MXT, degree=2) + poly(Rain, degree=2)"))

colnames(wts)<-sp_names

fm1 <- species_mix(archetype_formula = form, data = dat, weights = wts,
                   n_mixtures = 12, distribution = 'ippm',
                   standardise = TRUE,
                   control = species_mix.control(init_method = 'kmed',
                                                          cores = 1,
                                                          minimum_sites_prevelance = 0.025))
```

Spatial prediction
```{r}

df <- as.data.frame(covar)
df_no_na <- na.omit(df)
mf <- model.frame(~poly(min_temp,degree=2)+poly(max_temp,degree=2)+poly(annual_rainfall,degree=2),df_no_na)
mf <- as.matrix(mf)
preds <- predict(fm1,mf)

crds <- rasterToPoints(covar)[,1:2]
r <- rasterFromXYZ(cbind(crds,preds$predict_mus))
# x11()
par(mfrow=c(2,4),oma=c(.2,.2,.2,.2))
for(i in 1:8){
plot(r[[i]])
points(dat[!is.na(dat[,i]) & dat[,i]>0,c("x","y")],pch=16,cex=.5)
}
```

covar responses
```{r}
newobs <- apply(fm1$titbits$X,2,function(x)seq(range(x)[1],range(x)[2],length.out = 100))
object <- fm1

G <- object$G
S <- object$S
n <- object$n
np <- object$np

## To calculate fitted values, take a linear combination of the fitted mus from each component
partial_predict <- array(0,c(nrow(newobs),S,np))
for(ss in seq_len(S)){
  for(gg in seq_len(G)) {
    for(jj in seq_len(np)){
          etas.K <- object$coefs$alpha[ss] + newobs[,jj]*object$coef$beta[gg,jj]
    if(family == "gaussian") mus.K <- etas.K
    if(family == "bernoulli") mus.K <- exp(etas.K)/(1+exp(etas.K))
    if(family %in% c("poisson","ippm","negative_binomial")) partial_predict[,ss,jj] <- exp(etas.K)
    predict_mus <- predict_mus + matrix(object$taus[,gg],nrow(newobs),S,byrow=T)*mus.K
  }

```


